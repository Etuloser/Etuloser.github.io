[{"title":"final关键字","date":"2017-06-19T03:21:03.000Z","path":"2017/06/19/final关键字/","text":"最终，被final修饰的类叫最终类，如String类。 使用final修饰的类不能派生子类 使用final修饰的方法不能被子类所覆写 使用final修饰的变量即成为常量，常量不能修改 String类用final修饰有多方面原因，主要是不想让String被修改，涉及到hash值、常量池引用同一个字面量","tags":[]},{"title":"对象的多态性","date":"2017-06-19T03:20:19.000Z","path":"2017/06/19/对象的多态性/","text":"向上转型：父类 父类对象 = 子类实例 向下转型：子类 子类对象 = (子类)父类实例//即要强转类型 示例： 定义父类Father 123456public class Father &#123; public void say() &#123; System.out.println(\"我是父类的say方法\"); &#125;&#125; 定义子类Son1 12345678910public class Son1 extends Father &#123; public void say() &#123; System.out.println(\"我是Son1类的say方法\"); &#125; public void tell() &#123; System.out.println(\"我是Son1类的tell方法\"); &#125;&#125; 定义子类Son2 12345678910public class Son2 extends Father &#123; public void say() &#123; System.out.println(\"我是Son2类的say方法\"); &#125; public void tell() &#123; System.out.println(\"我是Son2类的tell方法\"); &#125;&#125; 向上转型 123Father father = new Son1();father.say()//此处调用的是子类覆写过的say方法father.tell()//报错，因为父类中没有tell方法 发生向上转型后，调用的一定是子类中的被覆写的方法 向下转型 1234Father father = new Son1()；Son1 son = (Son1)father;son.say();son.tell();//均可使用 值得注意的是，要向使用向下转型，必须先向上转型让子类与父类建立联系，否则会出现ClassCastException错误 应用场景：设计一个方法，要求此方法可以接受Father类的子类并调用相应放方法 123public void fun(Father father)&#123; father.say();&#125; 如果不使用向上转型，则需要给每个子类添加一个对应的fun(子类 参数名)方法，这显然不合理。 #instanceof 关键字 用来判断一个对象到底是哪个类的实例 1234Father father = new Son1();System.out.println(father instanceof Father);//tSystem.out.println(father instanceof Son1);//tSystem.out.println(father instanceof Son2);//f 在进行对象向下转型关系前最好先进行判断再进行相应的转型操作","tags":[]},{"title":"entity","date":"2017-06-19T03:18:48.000Z","path":"2017/06/19/entity/","text":"在日常的Java项目开发中，entity（实体类）是必不可少的，它们一般都有很多的属性，并有相应的setter和getter方法。entity（实体类）的作用一般是和数据表做映射。所以快速写出规范的entity（实体类）是java开发中一项必不可少的技能。 在项目中写实体类一般遵循下面的规范： 1、根据你的设计，定义一组你需要的私有属性。 2、根据这些属性，创建它们的setter和getter方法。（eclipse等集成开发软件可以自动生成。具体怎么生成？请自行百度。） 3、提供带参数的构造器和无参数的构造器。 4、重写父类中的eauals()方法和hashcode()方法。（如果需要涉及到两个对象之间的比较，这两个功能很重要。） 5、实现序列化并赋予其一个版本号。 下面是我写的一个实体类（entity）例子：具体的细节都用注释标注了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 1 class Student implements Serializable&#123; 2 /** 3 * 版本号 4 */ 5 private static final long serialVersionUID = 1L; 6 //定义的私有属性 7 private int id; 8 private String name; 9 private int age;10 private double score;11 //无参数的构造器12 public Student()&#123;13 14 &#125;15 //有参数的构造器16 public Student(int id,String name,int age, double score)&#123;17 this.id = id;18 this.name = name;19 this.age = age;20 this.score = score;21 &#125;22 //创建的setter和getter方法23 public int getId() &#123;24 return id;25 &#125;26 public void setId(int id) &#123;27 this.id = id;28 &#125;29 public String getName() &#123;30 return name;31 &#125;32 public void setName(String name) &#123;33 this.name = name;34 &#125;35 public int getAge() &#123;36 return age;37 &#125;38 public void setAge(int age) &#123;39 this.age = age;40 &#125;41 public double getScore() &#123;42 return score;43 &#125;44 public void setScore(double score) &#123;45 this.score = score;46 &#125;47 //由于id对于学生这个类是唯一可以标识的，所以重写了父类中的id的hashCode()和equals()方法。48 @Override49 public int hashCode() &#123;50 final int prime = 31;51 int result = 1;52 result = prime * result + id;53 return result;54 &#125;55 @Override56 public boolean equals(Object obj) &#123;57 if (this == obj)58 return true;59 if (obj == null)60 return false;61 if (getClass() != obj.getClass())62 return false;63 Student other = (Student) obj;64 if (id != other.id)65 return false;66 return true;67 &#125;68 69 &#125;一个学生的Java实体类就基本完成了。","tags":[]},{"title":"博客整理","date":"2017-06-13T07:54:08.000Z","path":"2017/06/13/博客整理/","text":"今天花了一点时间来整理博客，所幸还记得之前踩的坑，很快就部署起来了。","tags":[{"name":"随笔","slug":"随笔","permalink":"//etuloser.com/tags/随笔/"}]},{"title":"Pattern和Matcher","date":"2017-06-13T05:58:42.000Z","path":"2017/06/13/Pattern和Matcher/","text":"实例化过程 Pattern用于创建匹配模式，用complie实例 123Pattern p = Pattern.compile(\"正则表达式\");p.pattern()//以字符串的形式返回正则表达式 Matcher用于执行匹配，支持分组，多次匹配，用matcher方法实例 12345Pattern p = Pattern.compile(\"正则表达式\");Matcher m = p.matcher(\"要匹配的字符串\");m.pattern()//返回的是Pattern对象，由谁创建 1.Pattern.split(CharSequence input) 123456789Pattern p = Pattern.compile(\"正则表达式\");String s[] = p.split(\"要分割的字符串\");for(String str : s)&#123; System.out.println(str);&#125;//输出的结果是以匹配组分割的字符串数组 2.Pattern.matcher(String regex, CharSequence input) 123System.out.println(Pattern.matches(\"\\\\d+\",\"5465\"));//输出结果是true 3.Matcher.matches()/ Matcher.lookingAt()/ Matcher.find() 1//都返回布尔值 1.输出捕获组 123456String str = \"asdasdasd&#123;abc&#125;asdasdas&#123;ddd&#125;aasdasdasd&#123;ufo&#125;asdasd\"; Pattern p = Pattern.compile(\"\\\\&#123;\\\\w&#123;3&#125;\\\\&#125;\"); Matcher m = p.matcher(str); while (m.find())&#123; System.out.println(m.group().replaceAll(\"\\\\W\",\"\")); &#125; CharSequence是可读可写的字符串 String是只读字符串 \\b 匹配数字 \\w 匹配字母","tags":[{"name":"J2SE","slug":"J2SE","permalink":"//etuloser.com/tags/J2SE/"}]},{"title":"Maven","date":"2017-06-13T05:56:31.000Z","path":"2017/06/13/Maven/","text":"#安装及配置 https://maven.apache.org 配置环境变量M2_HOME并添加到path 配置settings.xml &lt;localRepository&gt;本地仓库&lt;/localRepository&gt; &lt;mirrors&gt;阿里云&lt;/mirrors&gt; 在IDEA设置maven相关配置 pom.xml配置： 123451.http://mvnrepository.com/2.&lt;dependencies&gt;&lt;/dependencies&gt;3.项目--右键--Maven--Reimport Tomcat设置： 1.添加Tomcat后到Deployment选择卡下把包放到lib下 2.在Server选择卡管理自动调起浏览器，改变Update方式 头文件12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocat","tags":[{"name":"Maven","slug":"Maven","permalink":"//etuloser.com/tags/Maven/"}]},{"title":"软件测试","date":"2017-06-13T05:53:58.000Z","path":"2017/06/13/软件测试/","text":"#软件测试的历史 #什么是软件测试 #早期定义 软件测试是对程序能按预期运行建立起一种信心 —— Bill Hetzel, 1973 #经典定义 测试是为发现错误而执行的过程 —— Myers, 1979 #IEEE定义（ISO/IEC/IEEE 29119） 使用人工或自动的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异 #软件测试的对象 Q:软件测试 = 程序测试？ A:当然不是，软件测试存在于软件研发的整个过程中，具体包括软件需求、软件概要设计、软件详细设计、软件的源码、可运行程序、软件运行环境，都是软件测试的测试对象 #五大要素和两个目标 两个重要目标 1.提高测试覆盖率：能有效的提高软件的质量 2.提高测试效率：能更好的完成软件测试 #软件测试所遵循的原则 一、测试显示缺陷的存在，但不能证明系统不存在缺陷 二、穷尽测试是不可能的，应设设定及时终止的条件 三、测试应尽早进行 四、缺陷具备群集特性 五、测试的杀虫剂悖论 六、测试的二八原则 七、测试活动依赖于测试背景 #软件测试的分类 #按测试阶段来分类 单元测试 集成测试 系统测试 验收测试 #单元测试 Q:什么是单元测试？ A:对软件的最小可测试单元进行检查和验证 #单元测试的原则 1.尽可能保证各个测试用例是互相独立的 2.一般由代码的开发人员来实施，用以检验所开发的代码功能符合自己的设计要求 #单元测试的益处 1.能尽早发现缺陷 2.有利于重构 3.简化集成 4.文档 5.用于设计 #单元测试的限制 1.不可能覆盖所有的执行路径，所以不可能保证捕捉到所有路径的错误 2.每一行代码，一般需要3~5行测试代码才能完成单元测试。所以存在投入和产出的一个平衡 #单元测试框架 Xunit、JUnit、nunit、PHPUnit、CPPUnit #集成测试 定义 是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动 #集成测试的主要实施方案 1.Big Bang 2.自顶向下 3.自底向上 4.核心系统测试 5.高频集成 集成测试&amp;单元测试 1.测试对象不同：前者以模块和子系统为单元进行测试，后者则是针对系统最小单元 2.测试的依据不同：前者的依据是概要，后者则是详细设计 3.测试的方法不同：前者关心的是模块接口之间的集成，后者只关心在单元的内部 #系统测试 定义 是将经过集成测试的软件，作为计算机系统的一部分，与系统中其他部分结合起来，在实际运行环境下对计算机系统进行的一系列严格有效地测试，以发现软件潜在的问，保证系统的正常运行。 关注点 关注系统本身的使用 关注系统与其他相关系统间的连通 关注系统在不同使用压力下的表现 关注系统在真实使用环境下的表现 系统测试&amp;集成测试 1.测试对象 集成测试：由通过了单元测试的各个模块所集成起来的构件 系统测试：除了软件之外，还包括计算机硬件及相关的外围设备、数据采集和传输机构、支持软件、系统操作人员等整个系统 2.测试时间 集成测试介于单元测试和系统测试之间测试 系统测试在集成测试之后 3.测试内容 集成测试：各个单元模块之间的接口 系统测试：整个系统的功能和性能 4.测试角度 集成测试：偏于技术角度的验证 系统测试：偏于业务角度的验证 #验收测试 定义 也称交付测试。针对用户需求、业务流程的正式的测试，确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统 细分 1.用户验收测试 2.运行验收测试 3.合同和规范验收测试 4.alpha测试 5.Beta测试 #按测试手段分类 1.黑盒测试、白盒测试 2.静态测试、动态测试 3.手工测试、自动化测试 #黑盒测试 优点 1.容易实施，不需要关注内部的实现 2.更贴近用户的使用角度 缺点 1.测试的覆盖率较低，一般只能覆盖到代码的不到40% 2.针对黑盒的自动化测试，复用率较低，维护成本高 主要测试什么 1.是否有不正确或遗漏的功能？ 2.在接口上，输入是否正确的接受？能否输出正确的结果？ 3.是否有数据结构错误或外部信息(例如数据文件)访问错误？ 4.性能上是否能够满足需求 主要涉及方法 #白盒测试 主要的逻辑单位：语句、条件、条件组合、分支、路径 优点 1.迫使测试人员去仔细思考软件的实现，理解原理 2.可以检测代码中的每条分支和路径 3.揭示隐藏在代码中的错误 4.对代码的测试比较彻底 缺点 1.昂贵。 2.无法检测代码中遗漏的路径和数据敏感性错误 3.不能直接验证需求的正确性 #白盒测试的主要测试方法 #灰盒测试 介于白、黑盒测试之间的，关注输出对于输入的正确性，同时也关注内部表现 #静态测试 定义 静态测试是指无须执行被测程序，而是通过评审软件文档或代码，度量程序静态复杂度，检查软件是否符合编程标准，借以发现编写的程序的不足之处，减少错误出现的概率 #动态测试 定义 动态测试是通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等。 #手工测试 由专门的测试人员从用户视角来验证软件是否满足设计要求的行为。更适用针对深度测试和强调主观判断的测试。 如：众包测试、探索式测试 #自动化测试 使用单独的测试工具软件控制测试的自动化执行以及对预期和结果进行自动检查。 单元测试、接口测试、性能测试等。 手工测试&amp;自动化测试 #按测试模式来分类 瀑布模型、敏捷测试、基于脚本的测试、基于风险的测试、探索式测试等 #传统瀑布模型： #优缺点： #V模型 #W模型 #X模型 #H模型 #敏捷测试 Agile Testing —— 遵循敏捷宣言的一种测试实践 敏捷宣言 1.个体与交互 重于 过程和工具 2.可用的软件 重于 完备的文档 3.客户协作 重于 合同谈判 4.响应变化 重于 遵循计划 在每对比较中、后者并非全无价值，但我们更看重前者 强调从客户角度进行测试 重点关注迭代测试新功能，不存在强调测试阶段 尽早测试，不间断测试，具备测试条件 强调持续反馈 预防缺陷重于发现缺陷 敏捷测试VS传统测试 #基于脚本的测试-SBT Script-based Testing Scripted Testing(ST) Exploratory Testing(ET) 探索式测试(ET) 完全抛开测试脚本的测试 它是一种测试风格、思维而不是一种测试技术 ET和ST使用 ST VS ET 探索式测试的忧点 1.更能激发测试人员的创造性和工作乐趣 2.增加了发现新的或较深入Bug的可能性 3.在较短时间内找到更多Bug以及对SUT作一个快速的评估 4.有利用更加有效地实施自动化 5.更加适用于敏捷项目 6.减少了在简单、繁复上用例的无谓编写时间 探索式测试的缺点 1.测试管理上有局限性，较难协调和控制 2.对于Bug的重复利用和重现上作用有限 3.对测试人员的测试技能和业务知识深度依赖较大 4.只有在SUT已经完全可用的前提下才更有作用 5.ET的生产率很难定义 6.ET本身较难进行自动化 局部探索式测试 输入 状态 代码路径 用户数据 执行环境 全局探索式测试 执行探索式测试 #基于风险的测试-RBT Rist-based Testing 一种基于对软件失效的风险评估并以此指导测试计划、设计、执行、结果评价的软件测试类型 哪些是风险？ 质量风险 管理风险 风险级别=风险可能性 X 风险严重度 识别风险 RBT的优点 #基于模型的测试-MBT Model-based testing is software testing in which test cases are derived in whole or in part from a model that describes some(usually funcional) aspects of the system under test(SUT). 主要的MBT工具 Spec Explorer(Microsoft) GraphWalker(OpenSource) Tcases(OpenSource) modeljunit(OpenSource) #按测试类型分类 功能测试 性能测试 部署测试 文档测试 安全测试 兼容性测试 易用性测试 本地化测试 无障碍测试 可靠性测试 #功能测试 根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定他们满足设计需求 针对的问题 功能错误或遗漏、界面问题、性能错误、数据及访问错误、初始化及终止错误 #功能测试工具 QTP winrunner silkTest Rational robot selenium Watir Sikuli #性能测试 负载测试 压力测试 稳定性测试 性能指标：并发用户数VU、每秒事务数TPS、系统响应时间、设备性能 性能测试工具：LoadRunner、Silkerformer、Jmeter、WebLoad、Apache Bench、LoadUI 静态性能评估： 开发Web应用时，基于一系列Web应用页面性能优化的最佳实践对Web应用的页面进行静态分析，并给出评估结果的性能分析方法。(YSlow、PageSpeed) #应用性能管理(APM) Application performance Management,提供对系统的实时监控以实现性能管理、故障管理的解决方案 #安全测试 对软件产品进行测试以确保其符合产品安全需求和质量标准 #渗透测试 通过模拟对软件系统的恶意攻击行为来评估系统安全性的一种测试 渗透测试&amp;安全测试 OWAP：Open Web Application Security Project OWAP Top 10 Test Guide #安全测试工具 Appscan Webinspect Nessus Nmap MetaSploit WebScarab Fortify W3AF #兼容性测试 软件本身的兼容性 不同平台下的兼容性 软件对运行设备的兼容性 软件互操作性 浏览器内核 Trident4-6 IE6-8，9，10 Gecko FireFox WebKit Safari、Chrome presto opera 浏览器兼容性测试工具 BrowserShots Browser Sandbox w3help #文档测试 针对软件产品的交付品，配套的文档类部件的测试。如用户手册、使用说明、用户帮助文档等。 文档测试关注要点 完整性、正确性、一致性、易理解性、易浏览性 #可靠性测试 软件可靠性 硬件可靠性 #易用性测试 易用性测试是指测试用户使用软件时是否感觉方便，是否能保证用户使用体验的测试类型。 #本地化测试 针对软件的本地化版本实施的针对性测试 主要测试内容 语言、书写习惯 时区、日期格式、货币 当地风俗、法律法规 政治敏感内容 #部署测试 也称安装测试，主要验证系统部署过程，并确保软件经过安装测试后可以正常使用。 主要测试内容 在不同环境下的部署验证 参照部署文档执行，过程的合理、正确性 基础数据 #无障碍测试 Accessibility Test.也称可访问性测试。是指软件需要提供便于特殊人群使用的功能，包括视障、听障、老年人、身体残疾用户等，无障碍测试则是针对这部分功能的测试。 #其他的一些测试类型概念 回归测试 冒烟测试 Monkey测试 AB测试 回归测试： 软件功能修改后，对软件进行重新测试以确认修改没有引入新的错误或导致其他部分产生错误。 回归测试的重心在关键模块和重点功能组件。 软件研发周期中会进行多次回归测试，且尽量实现自动化。 Monkey测试 Monkey测试，也称搞怪测试。就是用一些随机、稀奇古怪的方式来操作软件，以测试系统的健壮性和稳定性。 冒烟测试 来自于硬件板卡验证术语。软件上则用于确认代码中的更改会按预期运行，且不会破坏整个版本的稳定性。 A/B测试 多用于互联网行业，通过为页面提供2个版本给用户使用并记录相关的用户行为数据，来确定更优化设计的一种测试方案。 A/B测试实施要点 多个方案并行 每次测试仅改动一个变量 按照某种规则进行优胜劣汰 A/B测试工具 Googel Analytics Content Experiments Visual Website Optimizer #回顾总结","tags":[{"name":"软件测试","slug":"软件测试","permalink":"//etuloser.com/tags/软件测试/"}]},{"title":"favicon","date":"2017-03-01T05:24:04.000Z","path":"2017/03/01/favicon/","text":"在HTML中可以使用link标签来实现shortcut icon。 1&lt;link rel=\"shortcut icon\" type=\"images/x-icon\"href=\"http://www.baidu.com favicon.ico\"&gt; 把href换成自己网站的favicon即可。 参考：http://zh.wikipedia.org/wiki/Favicon 这里的favicon必须是1616或者3232的，必须是8位色或者24位色的，格式必须是png或者ico或者gif。1616/3232 且 8位或24位色 且 png/ico/gif。 另一种实现favicon的方法是把名为favicon.ico的图片放在WEB根目录下。这种方法不推荐，因为这种方法违反了互联网规范，这个图片的访问是没有被授权的。 参考：http://www.w3.org/2005/10/howto-favicon","tags":[{"name":"HTML","slug":"HTML","permalink":"//etuloser.com/tags/HTML/"}]},{"title":"prettify","date":"2017-03-01T04:57:33.000Z","path":"2017/03/01/prettify/","text":"使用Sublime text 3 编写代码是一种享受，使用Sublime text 3 格式化HTML代码，需要安装插件，具体安装步骤如下： 1、打开菜单-&gt;首选项-&gt;插件控制，输入 install package 2、等待程序进入插件管理功能，再输入插件名称：TAG 3、点击安装插件html-css-js prettify 。 4、插件安装成功后，在需要格式化的HTML代码中，选中代码，然后按Ctrl+Alt+H对代码进行格式化。 html-css-js prettify 格式化CSS会再每个CSS后面都添加一个换行，取消该换行的方法： 打开：菜单&gt;tools&gt;html/css/js prettify&gt;set prettify preferences修改设置newline_between_rules的参数为false","tags":[{"name":"Sublime","slug":"Sublime","permalink":"//etuloser.com/tags/Sublime/"}]},{"title":"检查一个字符串每个字符出现的次数","date":"2017-02-22T14:30:09.000Z","path":"2017/02/22/times/","text":"1234567891011var Str = \"hellohellohello\";var newStr = Str.split(\"\").sort();function times(Str) &#123; for (var i = 0; i &lt; len; i = lastIndex+1) &#123; var key = newStr[i]; var lastIndex = newStr.join(\"\").lastIndexOf(key); var count = lastIndex + 1 - i; console.log(key+\"出现了\"+ count +\"次\"); &#125;&#125;times(Str);","tags":[{"name":"算法","slug":"算法","permalink":"//etuloser.com/tags/算法/"}]},{"title":"不使用中间变量，交换a、b的值","date":"2017-02-22T10:50:32.000Z","path":"2017/02/22/swapValue/","text":"一个经典的算法题 实现方法有三种：加减法、异或法、乘除法。 加减法：该方法可以交换整型和浮点型数值的变量，但在处理浮点型的时候有可能出现精度的损失。 123a = a + b;b = a - b;a = a - b; 异或法：可以完成对整型变量的交换，对于浮点型变量它无法完成交换。 123a = a ^ b;b = a ^ b;a = a ^ b; 乘除法：可以处理整型和浮点型变量，但在处理浮点型变量时也存在精度损失问题。而且乘除法比加减法要多一条约束：b必不为0。 123a = a * bb = a / ba = a / b","tags":[{"name":"算法","slug":"算法","permalink":"//etuloser.com/tags/算法/"}]},{"title":"关于本博客","date":"2017-02-22T02:21:16.000Z","path":"2017/02/22/about-this-blog/","text":"本博客使用hexo搭建，部署在github page上，域名注册于godaddy，至于搭建方法，前辈们已经总结了很多详细的资料，在此不再赘述。 hexo常用命令 hexo g //静态部署 hexo d //部署到githubpage hexo clean //清静态部署 hexo s //运行服务器 hexo n “文章名” //新建文章 &lt;!--more--&gt; //文章缩略","tags":[{"name":"文档","slug":"文档","permalink":"//etuloser.com/tags/文档/"}]}]