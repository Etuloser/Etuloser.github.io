[{"title":"Mybatis","date":"2017-06-24T12:25:50.000Z","path":"2017/06/24/Mybatis/","text":"为了摆脱繁琐和枯燥的重复操作，减少代码重复率，mybatis是一个很好的选择 创建实体类映射表 123456789101112131415161718192021public class Category &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 配置mybatis-cfg.xml 12345678910111213141516171819&lt;!--包扫描--&gt;&lt;typeAliases&gt; &lt;package name=\"pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!--映射Category.xml--&gt; &lt;mappers&gt; &lt;mapper resource=\"pojo/Category.xml\"/&gt; &lt;/mappers&gt; 配置文件Category.xml 1234567891011121314151617&lt;mapper namespace=\"pojo\"&gt; &lt;insert id=\"addCategory\" parameterType=\"Category\"&gt; INTO INTO category_ (name) VALUE (#&#123;name&#125;) &lt;/insert&gt; &lt;delete id=\"delCategory\" parameterType=\"Category\"&gt; DELETE FROM category_ WHERE name = #&#123;name&#125; &lt;/delete&gt; &lt;select id=\"getCategory\" parameterType=\"_int\" resultType=\"Category\"&gt; SELECT * FROM category_ WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;update id=\"updateCategory\" parameterType=\"Category\"&gt; UPDATE category_ set name = #&#123;name&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;select id=\"listCategory\" resultType=\"Category\"&gt; SELECT * FROM category_ &lt;/select&gt;&lt;/mapper&gt;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"//etuloser.com/tags/Mybatis/"}]},{"title":"EL表达式","date":"2017-06-22T12:16:35.000Z","path":"2017/06/22/EL表达式/","text":"E L（Expression Language） 目的：为了使 JSP 写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化 果然是从前端借鉴过来的。。。 最好在 &#37;&#x40;&#112;&#x61;&#103;&#x65;&#x25; 标签中加上 isELIgnored=”false”,以开启 Tomcat 对 EL 表达式的支持 作用域优先级 pageContext&gt;request&gt;session&gt;application 可以方便的访问 JavaBean 中的属性 如：${user.name} 结合JSTL的 使用，进一步简化代码 123456&lt;c:forEach items=\"$&#123;heros&#125;\" var=\"hero\" varStatus=\"st\" &gt; &lt;tr&gt; &lt;td&gt;$&#123;st.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;hero&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 取参 EL表达式还可以做到request.getParameter(“name”) 这样的形式获取浏览器传递过来的参数 先把jstl.jsp代码改为如例所示，然后访问如下地址 http://127.0.0.1/jstl.jsp?name=abc &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot; isELIgnored=&quot;false&quot;%&gt; ${param.name} 进行比较","tags":[]},{"title":"Servlet","date":"2017-06-22T11:21:55.000Z","path":"2017/06/22/Servlet/","text":"####HttpServlet类 如果要开发一个可以处理HTTP请求的Servlet程序，则肯定要继承HttpServlet类，而且在自定义的Servlet类中至少还要覆写HttpServlet类中提供的doGet()方法 123protected void doGet(HttpServletRequest req,HttpServletResponse resp)throws ServletException,IOException//负责处理所有的get请求，2个参数分别用来接收和回应用户的请求 web.xml的配置： 需要配置的有： 123456789&lt;servlet&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;包.类&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;url-pattern&gt;页面映射&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; //这些写在web-app标签里，可以配置多个servlet-mapping 路径加载执行的是get请求 页面资源要放到web文件夹下 ####Servlet生命周期 1234567public void init() throws ServletExceptionpublic void init(ServletConfig config) throws ServletExceptionpublic abstract void service(ServletRequest req,ServletResponse res) throws ServletExcption,IOException public void destroy() 1.加载Servlet Web容器负责加载Servlet，当Web容器启动是或者是在第一次使用这个Servlet时，容器会负责创建Servlet实例，但是用户必须通过部署描述符（web.xml）指定Servlet的位置（Servlet所在的包.类名称），成功加载后，Web容器会通过反射的方式对Servlet进行实例化 2.初始化 当一个Servlet被实例化以后，容器将调用init()方法初始化这个对象，初始化的目的是为了让Servlet对象在处理客户端请求前完成一些初始化的工作，如建立数据库连接、读取资源信息等，如果初始化失败，则此Servlet将直接被卸载 3.处理服务 当有请求提交时，Servlet将调用service()方法（常用的是doGet()或doPost()）进行处理。在service()方法中，Servlet可以通过ServletRequest接收客户的请求，也可以利用ServletResponse设置响应信息 4.销毁 当Web容器关闭或者检测到一个Servlet要从容器中被删除时，会自动调用destroy()方法，以便让该实例释放掉所占用的资源 5.卸载 当一个Servlet调用玩destroy()方法后，此实例将等待被垃圾收集器所回收，如果需要再次使用此Servlet时，会重新调用init()方法初始化 ####取得其他内置对象 public HttpSession getSession() public HttpSession getSession(boolean create) //返回当前的session,如果没有则创建一个新的session对象返回 ServletContext对象 public ServletContext getServletContext() ####Servlet跳转 服务器跳转： 123public void forward(ServletRequest request,ServletResponse response)throws ServletExcption,IOEXceptionpublic void include(ServletRequest request,ServletResponse response)throws ServletExcption,IOEXception","tags":[{"name":"Servlet","slug":"Servlet","permalink":"//etuloser.com/tags/Servlet/"}]},{"title":"SpringMVC","date":"2017-06-22T11:04:43.000Z","path":"2017/06/22/SpringMVC/","text":"开始学习 SpringMVC 的时候从网上找了个例子，在部署到 Tomcat 上时候遇到了一个问题，我用的是 IDEA 在 IDEA 中导入项目后，需要手动添加 Tomcat 服务器，并且添加 artifacts，这个具体是什么我暂时不知道，留着以后探究，猜测应该是服务器 lib 依赖，这里只说如何做 1.在建立好项目，添加好 jar 包依赖后，开始配置 web.xml 配置 SpringMVC 的入口 DispatcherServlet 123456789&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.配置 Spring-servlet.xml, 这是 Spring MVC 的映射配置文件 表示访问 /index 路径会交由 id=indexController 的bean处理 123456789&lt;bean id=\"simpleUrlHandlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/index\"&gt;indexController&lt;/prop&gt; /props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"indexController\" class=\"controller.IndexController\"&gt;&lt;/bean&gt; 3.然后声明控制类 IndexController 控制类 IndexController实现接口 Controller，提供方法 handleRequest 处理请求 SpringMVC 通过 ModelAndView 对象把模型和视图结合在一起 12345678public class IndexController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(\"index.jsp\"); modelAndView.addObject(\"message\",\"Hello Spring MVC\"); return modelAndView; &#125;&#125; 视图定位 通过修改 sprinmvc-servlet.xml 来实现视图定位 1234&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 修改 IndexController 类 ModelAndView mav = new ModelAndView(&quot;index&quot;); 为什么要这样做？ 如果写死路径不利于维护修改 注解方式 同样 springmvc 也可以用注解来实现 声明 IndexController 是控制类,同时不再让IndexController实现Controller类 12@Controllerpublic class IndexController&#123;...&#125; 声明 handleRequest 方法是 RequestMapping 同时加上参数,表示路径/index会映射到该方法上 12@RequestMapping(\"/index\")public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)&#123;...&#125; 在配置文件里添加头文件标签约束并开启包扫描 头文件参考spring笔记 接受表单数据 浏览器提交数据是非常常见的场景，本例演示用户提交产品名称和价格到Spring MVC Spring MVC如何接受数据 个人喜欢从页面做起，先写一个提交数据的页面 addProduct.jsp 12345&lt;form action=\"/addProduct\"&gt; 产品名称：&lt;input type=\"text\" name=\"name\" value=\"\"&gt;&lt;br/&gt; 产品价格：&lt;input type=\"text\" name=\"price\" value=\"\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"增加商品\"&gt; &lt;/form&gt; 该jsp页面会把数据传到 /addProduct 下 声明 ProductController 控制器来处理 JSP 传过来的数据 123456789@Controllerpublic class ProductController &#123; @RequestMapping(\"/addProduct\") public ModelAndView add(Product product)throws Exception&#123; ModelAndView modelAndView = new ModelAndView(\"showProduct\"); return modelAndView; &#125;&#125; add 方法接受了 jsp 传过来的参数并把它们注入到了 product 对象里，并通过此对象生成了 showProduct 页面，相当于 modelAndView.addObject(&quot;product&quot;,product); 写 showProduct.jsp 页面来显示结果，用EL表达式 产品名称： ${product.name} 产品价格： ${product.price} 客户端跳转 123456@RequestMapping(\"/jump\")public ModelAndView jump() &#123; ModelAndView modelAndView = new ModelAndView(\"redirect:/index\"); return modelAndView;&#125; 显然，通过 redirect: 即可完成客户端跳转 刷session 1234567891011@RequestMapping(\"check\") public ModelAndView check(HttpSession session) &#123; Integer i = (Integer) session.getAttribute(\"count\"); if (i == null) &#123; i = 0; &#125; i++; session.setAttribute(\"count\", i); ModelAndView modelAndView = new ModelAndView(\"check\"); return modelAndView; &#125; filter 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 上传文件 1234567891011121314151617@Controllerpublic class UploadController &#123; @RequestMapping(\"/uploadImage\") public ModelAndView upload(HttpServletRequest request, HttpServletResponse response, UploadedImageFile file) throws IOException &#123; String name = RandomStringUtils.randomAlphanumeric(10); String newFileName = name + \".jpg\"; File newFile = new File(request.getServletContext().getRealPath(\"/image\"),newFileName); newFile.getParentFile().mkdir(); file.getImage().transferTo(newFile); ModelAndView modelAndView = new ModelAndView(\"showUploadedFile\"); modelAndView.addObject(\"imageName\",newFileName); return modelAndView; &#125;&#125;","tags":[]},{"title":"ajax","date":"2017-06-19T12:56:38.000Z","path":"2017/06/19/ajax/","text":"Ajax(Asynchronous JavaScript and XML, 异步的 JavaScript 和 XML) 局部刷新 主要包含 HTML、JavaScript、XML、DOM、XMLHttpRequest 等页面技术，核心是XMLHttpRequest对象","tags":[]},{"title":"Spring-IOC、DI","date":"2017-06-19T04:53:25.000Z","path":"2017/06/19/Spring/","text":"Spring 的核心就是 IOC、DI 和 AOP IOC (Inversion Of Controller) 反转控制，简单来说就是由new关键字创建对象变成交由Spring容器来创建 DI (Dependency Inject) 依赖注入，简单来说就是拿到的对象，已经被注入好相关值了，直接使用即可 由一个例子来演示 IOC 和 DI 首先创建一个 POJO 123456789101112131415161718192021public class Category &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 由 Spring 创建对象,并注入了 name 1234&lt;bean name=\"Category\" class=\"com.etuloser.POJO.Category\"&gt; &lt;property name=\"name\" value=\"category\"/&gt;&lt;/bean&gt; 测试 12345678public class TestCategory &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"applicationContext.xml\"&#125;); Category category = (Category) context.getBean(\"Category\"); System.out.println(category.getName()); &#125;&#125; 也可以把一个对象注入到另一个对象里 &lt;property name=&quot;category&quot; ref=&quot;Category&quot;/&gt; 注意要用 ref 以上是通过 XML 的方式来注入对象，我们也可以用注解的方式来完成注入对象的效果 首先在 xml 文件头文件里添加标签约束 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; 然后告知 Spring 要用注解的方式进行配置 &lt;context:annotation-config/&gt; 再使用 @Autowired 或者 @Resource 注解让类或者方法自动装载 以上是对注入对象行为进行注解，那么 Bean 对象本身是否可以也通过注解而脱离xml配置文件进行呢？答案是可以的 在xml文件中声明开启包扫描 &lt;context:component-scan base-package=&quot;com.how2java.pojo&quot;/&gt; 通过 @Component 注解声明此类是Bean @Component(&quot;Category&quot;) Other xml配置文件中标签的id属性和name属性基本上没有什么区别，但是使用id会更加符合规范，因为xml中id要求是唯一的","tags":[{"name":"Spring","slug":"Spring","permalink":"//etuloser.com/tags/Spring/"}]},{"title":"Annotation","date":"2017-06-19T03:27:50.000Z","path":"2017/06/19/Annotation/","text":"Annotation (注释)，用来对程序进行补充说明，无论是否使用注释都不影响原程序的运行 java.lang.annotation.Annotation 是 Annotation 的接口，只要是Annotat都必须实现此接口 123456public interface Annotation &#123; public Class&lt;? extends Annotataion&gt; annotationType(); public boolean equals(Object obj); String toString();&#125; @Override 保证方法正确覆写 Deprecated 声明一个不建议使用的方法 ####自定义Annotation 1234[public] @interface Annotation名称 &#123; 数据类型 变量名称()&#125; 使用@interface就相当于继承了Annotation接口","tags":[]},{"title":"final关键字","date":"2017-06-19T03:21:03.000Z","path":"2017/06/19/final关键字/","text":"最终，被final修饰的类叫最终类，如String类。 使用final修饰的类不能派生子类 使用final修饰的方法不能被子类所覆写 使用final修饰的变量即成为常量，常量不能修改 String类用final修饰有多方面原因，主要是不想让String被修改，涉及到hash值、常量池引用同一个字面量","tags":[]},{"title":"对象的多态性","date":"2017-06-19T03:20:19.000Z","path":"2017/06/19/对象的多态性/","text":"向上转型：父类 父类对象 = 子类实例 向下转型：子类 子类对象 = (子类)父类实例//即要强转类型 示例： 定义父类Father 123456public class Father &#123; public void say() &#123; System.out.println(\"我是父类的say方法\"); &#125;&#125; 定义子类Son1 12345678910public class Son1 extends Father &#123; public void say() &#123; System.out.println(\"我是Son1类的say方法\"); &#125; public void tell() &#123; System.out.println(\"我是Son1类的tell方法\"); &#125;&#125; 定义子类Son2 12345678910public class Son2 extends Father &#123; public void say() &#123; System.out.println(\"我是Son2类的say方法\"); &#125; public void tell() &#123; System.out.println(\"我是Son2类的tell方法\"); &#125;&#125; 向上转型 123Father father = new Son1();father.say()//此处调用的是子类覆写过的say方法father.tell()//报错，因为父类中没有tell方法 发生向上转型后，调用的一定是子类中的被覆写的方法 向下转型 1234Father father = new Son1()；Son1 son = (Son1)father;son.say();son.tell();//均可使用 值得注意的是，要向使用向下转型，必须先向上转型让子类与父类建立联系，否则会出现ClassCastException错误 应用场景：设计一个方法，要求此方法可以接受Father类的子类并调用相应放方法 123public void fun(Father father)&#123; father.say();&#125; 如果不使用向上转型，则需要给每个子类添加一个对应的fun(子类 参数名)方法，这显然不合理。 #instanceof 关键字 用来判断一个对象到底是哪个类的实例 1234Father father = new Son1();System.out.println(father instanceof Father);//tSystem.out.println(father instanceof Son1);//tSystem.out.println(father instanceof Son2);//f 在进行对象向下转型关系前最好先进行判断再进行相应的转型操作","tags":[]},{"title":"entity","date":"2017-06-19T03:18:48.000Z","path":"2017/06/19/entity/","text":"在日常的Java项目开发中，entity（实体类）是必不可少的，它们一般都有很多的属性，并有相应的setter和getter方法。entity（实体类）的作用一般是和数据表做映射。所以快速写出规范的entity（实体类）是java开发中一项必不可少的技能。 在项目中写实体类一般遵循下面的规范： 1、根据你的设计，定义一组你需要的私有属性。 2、根据这些属性，创建它们的setter和getter方法。（eclipse等集成开发软件可以自动生成。具体怎么生成？请自行百度。） 3、提供带参数的构造器和无参数的构造器。 4、重写父类中的eauals()方法和hashcode()方法。（如果需要涉及到两个对象之间的比较，这两个功能很重要。） 5、实现序列化并赋予其一个版本号。 下面是我写的一个实体类（entity）例子：具体的细节都用注释标注了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 1 class Student implements Serializable&#123; 2 /** 3 * 版本号 4 */ 5 private static final long serialVersionUID = 1L; 6 //定义的私有属性 7 private int id; 8 private String name; 9 private int age;10 private double score;11 //无参数的构造器12 public Student()&#123;13 14 &#125;15 //有参数的构造器16 public Student(int id,String name,int age, double score)&#123;17 this.id = id;18 this.name = name;19 this.age = age;20 this.score = score;21 &#125;22 //创建的setter和getter方法23 public int getId() &#123;24 return id;25 &#125;26 public void setId(int id) &#123;27 this.id = id;28 &#125;29 public String getName() &#123;30 return name;31 &#125;32 public void setName(String name) &#123;33 this.name = name;34 &#125;35 public int getAge() &#123;36 return age;37 &#125;38 public void setAge(int age) &#123;39 this.age = age;40 &#125;41 public double getScore() &#123;42 return score;43 &#125;44 public void setScore(double score) &#123;45 this.score = score;46 &#125;47 //由于id对于学生这个类是唯一可以标识的，所以重写了父类中的id的hashCode()和equals()方法。48 @Override49 public int hashCode() &#123;50 final int prime = 31;51 int result = 1;52 result = prime * result + id;53 return result;54 &#125;55 @Override56 public boolean equals(Object obj) &#123;57 if (this == obj)58 return true;59 if (obj == null)60 return false;61 if (getClass() != obj.getClass())62 return false;63 Student other = (Student) obj;64 if (id != other.id)65 return false;66 return true;67 &#125;68 69 &#125;一个学生的Java实体类就基本完成了。","tags":[]},{"title":"博客整理","date":"2017-06-13T07:54:08.000Z","path":"2017/06/13/博客整理/","text":"今天花了一点时间来整理博客，所幸还记得之前踩的坑，很快就部署起来了。","tags":[{"name":"随笔","slug":"随笔","permalink":"//etuloser.com/tags/随笔/"}]},{"title":"Pattern和Matcher","date":"2017-06-13T05:58:42.000Z","path":"2017/06/13/Pattern和Matcher/","text":"实例化过程 Pattern用于创建匹配模式，用complie实例 123Pattern p = Pattern.compile(\"正则表达式\");p.pattern()//以字符串的形式返回正则表达式 Matcher用于执行匹配，支持分组，多次匹配，用matcher方法实例 12345Pattern p = Pattern.compile(\"正则表达式\");Matcher m = p.matcher(\"要匹配的字符串\");m.pattern()//返回的是Pattern对象，由谁创建 1.Pattern.split(CharSequence input) 123456789Pattern p = Pattern.compile(\"正则表达式\");String s[] = p.split(\"要分割的字符串\");for(String str : s)&#123; System.out.println(str);&#125;//输出的结果是以匹配组分割的字符串数组 2.Pattern.matcher(String regex, CharSequence input) 123System.out.println(Pattern.matches(\"\\\\d+\",\"5465\"));//输出结果是true 3.Matcher.matches()/ Matcher.lookingAt()/ Matcher.find() 1//都返回布尔值 1.输出捕获组 123456String str = \"asdasdasd&#123;abc&#125;asdasdas&#123;ddd&#125;aasdasdasd&#123;ufo&#125;asdasd\"; Pattern p = Pattern.compile(\"\\\\&#123;\\\\w&#123;3&#125;\\\\&#125;\"); Matcher m = p.matcher(str); while (m.find())&#123; System.out.println(m.group().replaceAll(\"\\\\W\",\"\")); &#125; CharSequence是可读可写的字符串 String是只读字符串 \\b 匹配数字 \\w 匹配字母","tags":[{"name":"J2SE","slug":"J2SE","permalink":"//etuloser.com/tags/J2SE/"}]},{"title":"Maven","date":"2017-06-13T05:56:31.000Z","path":"2017/06/13/Maven/","text":"安装及配置 https://maven.apache.org 配置环境变量 M2_HOME 并添加到 path (E:\\develop\\maven) 配置 settings.xml (E:\\develop\\maven\\conf) 1234567891011&lt;!--本地仓库位置--&gt;&lt;localRepository&gt; F:/documents/mavenRepository &lt;/localRepository&gt;&lt;!--国内镜像--&gt;&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 在 IDEA 设置 maven 相关配置 解决 archetype 加载慢的问题 https://maven.apache.org/archetype/archetype-models/archetype-catalog/archetype-catalog.html 从以上网址找到 archetype-catalog.xml 放到 F:\\Documents\\mavenRepository\\org\\apache\\maven\\archetype\\archetype-catalog\\3.0.1 如下图在 IDEA 设置从本地加载 archetype-catalog.xml（-DarchetypeCatalog=local） Tomcat设置： 1.添加Tomcat后到Deployment选择卡下把包放到lib下 2.在Server选择卡管理自动调起浏览器，改变Update方式","tags":[{"name":"Maven","slug":"Maven","permalink":"//etuloser.com/tags/Maven/"}]},{"title":"软件测试","date":"2017-06-13T05:53:58.000Z","path":"2017/06/13/软件测试/","text":"#软件测试的历史 #什么是软件测试 #早期定义 软件测试是对程序能按预期运行建立起一种信心 —— Bill Hetzel, 1973 #经典定义 测试是为发现错误而执行的过程 —— Myers, 1979 #IEEE定义（ISO/IEC/IEEE 29119） 使用人工或自动的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异 #软件测试的对象 Q:软件测试 = 程序测试？ A:当然不是，软件测试存在于软件研发的整个过程中，具体包括软件需求、软件概要设计、软件详细设计、软件的源码、可运行程序、软件运行环境，都是软件测试的测试对象 #五大要素和两个目标 两个重要目标 1.提高测试覆盖率：能有效的提高软件的质量 2.提高测试效率：能更好的完成软件测试 #软件测试所遵循的原则 一、测试显示缺陷的存在，但不能证明系统不存在缺陷 二、穷尽测试是不可能的，应设设定及时终止的条件 三、测试应尽早进行 四、缺陷具备群集特性 五、测试的杀虫剂悖论 六、测试的二八原则 七、测试活动依赖于测试背景 #软件测试的分类 #按测试阶段来分类 单元测试 集成测试 系统测试 验收测试 #单元测试 Q:什么是单元测试？ A:对软件的最小可测试单元进行检查和验证 #单元测试的原则 1.尽可能保证各个测试用例是互相独立的 2.一般由代码的开发人员来实施，用以检验所开发的代码功能符合自己的设计要求 #单元测试的益处 1.能尽早发现缺陷 2.有利于重构 3.简化集成 4.文档 5.用于设计 #单元测试的限制 1.不可能覆盖所有的执行路径，所以不可能保证捕捉到所有路径的错误 2.每一行代码，一般需要3~5行测试代码才能完成单元测试。所以存在投入和产出的一个平衡 #单元测试框架 Xunit、JUnit、nunit、PHPUnit、CPPUnit #集成测试 定义 是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动 #集成测试的主要实施方案 1.Big Bang 2.自顶向下 3.自底向上 4.核心系统测试 5.高频集成 集成测试&amp;单元测试 1.测试对象不同：前者以模块和子系统为单元进行测试，后者则是针对系统最小单元 2.测试的依据不同：前者的依据是概要，后者则是详细设计 3.测试的方法不同：前者关心的是模块接口之间的集成，后者只关心在单元的内部 #系统测试 定义 是将经过集成测试的软件，作为计算机系统的一部分，与系统中其他部分结合起来，在实际运行环境下对计算机系统进行的一系列严格有效地测试，以发现软件潜在的问，保证系统的正常运行。 关注点 关注系统本身的使用 关注系统与其他相关系统间的连通 关注系统在不同使用压力下的表现 关注系统在真实使用环境下的表现 系统测试&amp;集成测试 1.测试对象 集成测试：由通过了单元测试的各个模块所集成起来的构件 系统测试：除了软件之外，还包括计算机硬件及相关的外围设备、数据采集和传输机构、支持软件、系统操作人员等整个系统 2.测试时间 集成测试介于单元测试和系统测试之间测试 系统测试在集成测试之后 3.测试内容 集成测试：各个单元模块之间的接口 系统测试：整个系统的功能和性能 4.测试角度 集成测试：偏于技术角度的验证 系统测试：偏于业务角度的验证 #验收测试 定义 也称交付测试。针对用户需求、业务流程的正式的测试，确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统 细分 1.用户验收测试 2.运行验收测试 3.合同和规范验收测试 4.alpha测试 5.Beta测试 #按测试手段分类 1.黑盒测试、白盒测试 2.静态测试、动态测试 3.手工测试、自动化测试 #黑盒测试 优点 1.容易实施，不需要关注内部的实现 2.更贴近用户的使用角度 缺点 1.测试的覆盖率较低，一般只能覆盖到代码的不到40% 2.针对黑盒的自动化测试，复用率较低，维护成本高 主要测试什么 1.是否有不正确或遗漏的功能？ 2.在接口上，输入是否正确的接受？能否输出正确的结果？ 3.是否有数据结构错误或外部信息(例如数据文件)访问错误？ 4.性能上是否能够满足需求 主要涉及方法 #白盒测试 主要的逻辑单位：语句、条件、条件组合、分支、路径 优点 1.迫使测试人员去仔细思考软件的实现，理解原理 2.可以检测代码中的每条分支和路径 3.揭示隐藏在代码中的错误 4.对代码的测试比较彻底 缺点 1.昂贵。 2.无法检测代码中遗漏的路径和数据敏感性错误 3.不能直接验证需求的正确性 #白盒测试的主要测试方法 #灰盒测试 介于白、黑盒测试之间的，关注输出对于输入的正确性，同时也关注内部表现 #静态测试 定义 静态测试是指无须执行被测程序，而是通过评审软件文档或代码，度量程序静态复杂度，检查软件是否符合编程标准，借以发现编写的程序的不足之处，减少错误出现的概率 #动态测试 定义 动态测试是通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等。 #手工测试 由专门的测试人员从用户视角来验证软件是否满足设计要求的行为。更适用针对深度测试和强调主观判断的测试。 如：众包测试、探索式测试 #自动化测试 使用单独的测试工具软件控制测试的自动化执行以及对预期和结果进行自动检查。 单元测试、接口测试、性能测试等。 手工测试&amp;自动化测试 #按测试模式来分类 瀑布模型、敏捷测试、基于脚本的测试、基于风险的测试、探索式测试等 #传统瀑布模型： #优缺点： #V模型 #W模型 #X模型 #H模型 #敏捷测试 Agile Testing —— 遵循敏捷宣言的一种测试实践 敏捷宣言 1.个体与交互 重于 过程和工具 2.可用的软件 重于 完备的文档 3.客户协作 重于 合同谈判 4.响应变化 重于 遵循计划 在每对比较中、后者并非全无价值，但我们更看重前者 强调从客户角度进行测试 重点关注迭代测试新功能，不存在强调测试阶段 尽早测试，不间断测试，具备测试条件 强调持续反馈 预防缺陷重于发现缺陷 敏捷测试VS传统测试 #基于脚本的测试-SBT Script-based Testing Scripted Testing(ST) Exploratory Testing(ET) 探索式测试(ET) 完全抛开测试脚本的测试 它是一种测试风格、思维而不是一种测试技术 ET和ST使用 ST VS ET 探索式测试的忧点 1.更能激发测试人员的创造性和工作乐趣 2.增加了发现新的或较深入Bug的可能性 3.在较短时间内找到更多Bug以及对SUT作一个快速的评估 4.有利用更加有效地实施自动化 5.更加适用于敏捷项目 6.减少了在简单、繁复上用例的无谓编写时间 探索式测试的缺点 1.测试管理上有局限性，较难协调和控制 2.对于Bug的重复利用和重现上作用有限 3.对测试人员的测试技能和业务知识深度依赖较大 4.只有在SUT已经完全可用的前提下才更有作用 5.ET的生产率很难定义 6.ET本身较难进行自动化 局部探索式测试 输入 状态 代码路径 用户数据 执行环境 全局探索式测试 执行探索式测试 #基于风险的测试-RBT Rist-based Testing 一种基于对软件失效的风险评估并以此指导测试计划、设计、执行、结果评价的软件测试类型 哪些是风险？ 质量风险 管理风险 风险级别=风险可能性 X 风险严重度 识别风险 RBT的优点 #基于模型的测试-MBT Model-based testing is software testing in which test cases are derived in whole or in part from a model that describes some(usually funcional) aspects of the system under test(SUT). 主要的MBT工具 Spec Explorer(Microsoft) GraphWalker(OpenSource) Tcases(OpenSource) modeljunit(OpenSource) #按测试类型分类 功能测试 性能测试 部署测试 文档测试 安全测试 兼容性测试 易用性测试 本地化测试 无障碍测试 可靠性测试 #功能测试 根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定他们满足设计需求 针对的问题 功能错误或遗漏、界面问题、性能错误、数据及访问错误、初始化及终止错误 #功能测试工具 QTP winrunner silkTest Rational robot selenium Watir Sikuli #性能测试 负载测试 压力测试 稳定性测试 性能指标：并发用户数VU、每秒事务数TPS、系统响应时间、设备性能 性能测试工具：LoadRunner、Silkerformer、Jmeter、WebLoad、Apache Bench、LoadUI 静态性能评估： 开发Web应用时，基于一系列Web应用页面性能优化的最佳实践对Web应用的页面进行静态分析，并给出评估结果的性能分析方法。(YSlow、PageSpeed) #应用性能管理(APM) Application performance Management,提供对系统的实时监控以实现性能管理、故障管理的解决方案 #安全测试 对软件产品进行测试以确保其符合产品安全需求和质量标准 #渗透测试 通过模拟对软件系统的恶意攻击行为来评估系统安全性的一种测试 渗透测试&amp;安全测试 OWAP：Open Web Application Security Project OWAP Top 10 Test Guide #安全测试工具 Appscan Webinspect Nessus Nmap MetaSploit WebScarab Fortify W3AF #兼容性测试 软件本身的兼容性 不同平台下的兼容性 软件对运行设备的兼容性 软件互操作性 浏览器内核 Trident4-6 IE6-8，9，10 Gecko FireFox WebKit Safari、Chrome presto opera 浏览器兼容性测试工具 BrowserShots Browser Sandbox w3help #文档测试 针对软件产品的交付品，配套的文档类部件的测试。如用户手册、使用说明、用户帮助文档等。 文档测试关注要点 完整性、正确性、一致性、易理解性、易浏览性 #可靠性测试 软件可靠性 硬件可靠性 #易用性测试 易用性测试是指测试用户使用软件时是否感觉方便，是否能保证用户使用体验的测试类型。 #本地化测试 针对软件的本地化版本实施的针对性测试 主要测试内容 语言、书写习惯 时区、日期格式、货币 当地风俗、法律法规 政治敏感内容 #部署测试 也称安装测试，主要验证系统部署过程，并确保软件经过安装测试后可以正常使用。 主要测试内容 在不同环境下的部署验证 参照部署文档执行，过程的合理、正确性 基础数据 #无障碍测试 Accessibility Test.也称可访问性测试。是指软件需要提供便于特殊人群使用的功能，包括视障、听障、老年人、身体残疾用户等，无障碍测试则是针对这部分功能的测试。 #其他的一些测试类型概念 回归测试 冒烟测试 Monkey测试 AB测试 回归测试： 软件功能修改后，对软件进行重新测试以确认修改没有引入新的错误或导致其他部分产生错误。 回归测试的重心在关键模块和重点功能组件。 软件研发周期中会进行多次回归测试，且尽量实现自动化。 Monkey测试 Monkey测试，也称搞怪测试。就是用一些随机、稀奇古怪的方式来操作软件，以测试系统的健壮性和稳定性。 冒烟测试 来自于硬件板卡验证术语。软件上则用于确认代码中的更改会按预期运行，且不会破坏整个版本的稳定性。 A/B测试 多用于互联网行业，通过为页面提供2个版本给用户使用并记录相关的用户行为数据，来确定更优化设计的一种测试方案。 A/B测试实施要点 多个方案并行 每次测试仅改动一个变量 按照某种规则进行优胜劣汰 A/B测试工具 Googel Analytics Content Experiments Visual Website Optimizer #回顾总结","tags":[{"name":"软件测试","slug":"软件测试","permalink":"//etuloser.com/tags/软件测试/"}]},{"title":"favicon","date":"2017-03-01T05:24:04.000Z","path":"2017/03/01/favicon/","text":"在HTML中可以使用link标签来实现shortcut icon。 1&lt;link rel=\"shortcut icon\" type=\"images/x-icon\"href=\"http://www.baidu.com favicon.ico\"&gt; 把href换成自己网站的favicon即可。 参考：http://zh.wikipedia.org/wiki/Favicon 这里的favicon必须是1616或者3232的，必须是8位色或者24位色的，格式必须是png或者ico或者gif。1616/3232 且 8位或24位色 且 png/ico/gif。 另一种实现favicon的方法是把名为favicon.ico的图片放在WEB根目录下。这种方法不推荐，因为这种方法违反了互联网规范，这个图片的访问是没有被授权的。 参考：http://www.w3.org/2005/10/howto-favicon","tags":[{"name":"HTML","slug":"HTML","permalink":"//etuloser.com/tags/HTML/"}]},{"title":"prettify","date":"2017-03-01T04:57:33.000Z","path":"2017/03/01/prettify/","text":"使用Sublime text 3 编写代码是一种享受，使用Sublime text 3 格式化HTML代码，需要安装插件，具体安装步骤如下： 1、打开菜单-&gt;首选项-&gt;插件控制，输入 install package 2、等待程序进入插件管理功能，再输入插件名称：TAG 3、点击安装插件html-css-js prettify 。 4、插件安装成功后，在需要格式化的HTML代码中，选中代码，然后按Ctrl+Alt+H对代码进行格式化。 html-css-js prettify 格式化CSS会再每个CSS后面都添加一个换行，取消该换行的方法： 打开：菜单&gt;tools&gt;html/css/js prettify&gt;set prettify preferences修改设置newline_between_rules的参数为false","tags":[{"name":"Sublime","slug":"Sublime","permalink":"//etuloser.com/tags/Sublime/"}]},{"title":"检查一个字符串每个字符出现的次数","date":"2017-02-22T14:30:09.000Z","path":"2017/02/22/times/","text":"1234567891011var Str = \"hellohellohello\";var newStr = Str.split(\"\").sort();function times(Str) &#123; for (var i = 0; i &lt; len; i = lastIndex+1) &#123; var key = newStr[i]; var lastIndex = newStr.join(\"\").lastIndexOf(key); var count = lastIndex + 1 - i; console.log(key+\"出现了\"+ count +\"次\"); &#125;&#125;times(Str);","tags":[{"name":"算法","slug":"算法","permalink":"//etuloser.com/tags/算法/"}]},{"title":"不使用中间变量，交换a、b的值","date":"2017-02-22T10:50:32.000Z","path":"2017/02/22/swapValue/","text":"一个经典的算法题 实现方法有三种：加减法、异或法、乘除法。 加减法：该方法可以交换整型和浮点型数值的变量，但在处理浮点型的时候有可能出现精度的损失。 123a = a + b;b = a - b;a = a - b; 异或法：可以完成对整型变量的交换，对于浮点型变量它无法完成交换。 123a = a ^ b;b = a ^ b;a = a ^ b; 乘除法：可以处理整型和浮点型变量，但在处理浮点型变量时也存在精度损失问题。而且乘除法比加减法要多一条约束：b必不为0。 123a = a * bb = a / ba = a / b","tags":[{"name":"算法","slug":"算法","permalink":"//etuloser.com/tags/算法/"}]},{"title":"关于本博客","date":"2017-02-22T02:21:16.000Z","path":"2017/02/22/about-this-blog/","text":"本博客使用hexo搭建，部署在github page上，域名注册于godaddy，至于搭建方法，前辈们已经总结了很多详细的资料，在此不再赘述。 hexo常用命令 hexo g //静态部署 hexo d //部署到githubpage hexo clean //清静态部署 hexo s //运行服务器 hexo n “文章名” //新建文章 &lt;!--more--&gt; //文章缩略","tags":[{"name":"文档","slug":"文档","permalink":"//etuloser.com/tags/文档/"}]}]